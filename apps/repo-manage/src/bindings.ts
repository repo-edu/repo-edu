
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Load settings from disk with warnings for any corrected issues
 */
async loadSettings() : Promise<Result<SettingsLoadResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load app-level settings (theme, window position, etc.)
 */
async loadAppSettings() : Promise<Result<AppSettings, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_app_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save only app-level settings (theme, window position, etc.)
 */
async saveAppSettings(settings: AppSettings) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_app_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Reset settings to defaults
 */
async resetSettings() : Promise<Result<GuiSettings, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get default settings (single source of truth from Rust)
 */
async getDefaultSettings() : Promise<GuiSettings> {
    return await TAURI_INVOKE("get_default_settings");
},
/**
 * Get settings file path
 */
async getSettingsPath() : Promise<Result<string, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_settings_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if settings file exists
 */
async settingsExist() : Promise<Result<boolean, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("settings_exist") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Import settings from a specific file
 */
async importSettings(path: string) : Promise<Result<GuiSettings, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_settings", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Export settings to a specific file
 */
async exportSettings(settings: GuiSettings, path: string) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_settings", { settings, path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the JSON schema for GuiSettings
 */
async getSettingsSchema() : Promise<Result<string, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_settings_schema") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load settings or return defaults (never fails)
 */
async loadSettingsOrDefault() : Promise<Result<GuiSettings, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_settings_or_default") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all available profiles
 */
async listProfiles() : Promise<Result<string[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_profiles") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the currently active profile
 */
async getActiveProfile() : Promise<Result<string | null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_active_profile") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set the active profile
 */
async setActiveProfile(name: string) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_active_profile", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load a profile by name, returning any migration warnings
 */
async loadProfile(name: string) : Promise<Result<SettingsLoadResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_profile", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save profile settings as a named profile (app settings are not touched)
 */
async saveProfile(name: string, settings: ProfileSettings) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_profile", { name, settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a profile by name
 */
async deleteProfile(name: string) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_profile", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Rename a profile
 */
async renameProfile(oldName: string, newName: string) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("rename_profile", { oldName, newName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get token generation instructions for an LMS type
 */
async getTokenInstructions(lmsType: string) : Promise<Result<string, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_token_instructions", { lmsType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Open the LMS token generation page in the browser
 */
async openTokenUrl(baseUrl: string, lmsType: string) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_token_url", { baseUrl, lmsType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Verify LMS course credentials and fetch course information
 */
async verifyLmsCourse(params: VerifyCourseParams) : Promise<Result<VerifyCourseResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("verify_lms_course", { params }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Generate student files from an LMS course
 */
async generateLmsFiles(params: GenerateFilesParams, progress: TAURI_CHANNEL<string>) : Promise<Result<CommandResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_lms_files", { params, progress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get group categories (group sets) for a course
 */
async getGroupCategories(params: GetGroupCategoriesParams) : Promise<Result<GroupCategory[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_group_categories", { params }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get groups for a course
 */
async getGroups(params: GetGroupsParams) : Promise<Result<Group[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_groups", { params }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Verify platform configuration and authentication
 */
async verifyConfig(params: ConfigParams) : Promise<Result<CommandResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("verify_config", { params }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create student repositories from templates
 */
async setupRepos(params: SetupParams) : Promise<Result<CommandResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("setup_repos", { params }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Clone student repositories (stub for now)
 */
async cloneRepos(params: CloneParams) : Promise<Result<CommandResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clone_repos", { params }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Active tab in the GUI
 */
export type ActiveTab = "lms" | "repo"
/**
 * Unified error type for all Tauri commands
 */
export type AppError = { 
/**
 * User-friendly error message
 */
message: string; 
/**
 * Optional technical details for debugging
 */
details?: string | null }
/**
 * App-level settings stored in app.json
 * These are UI/window settings that don't belong in profiles
 */
export type AppSettings = { active_tab: ActiveTab; 
/**
 * IDs of collapsed sections (e.g., ["lms-config", "options"])
 */
collapsed_sections?: string[]; logging: LogSettings; sidebar_open: boolean; theme: Theme; window_height: number; window_width: number }
/**
 * Canvas-specific LMS configuration
 */
export type CanvasConfig = { access_token: string; base_url: string; courses: CourseEntry[]; custom_url: string; url_option: LmsUrlOption }
export type CloneParams = { config: ConfigParams; yaml_file: string; assignments: string; target_folder: string; directory_layout: string }
export type CommandResult = { success: boolean; message: string; details: string | null }
export type ConfigParams = { access_token: string; user: string; base_url: string; student_repos: string; template: string }
/**
 * A course entry with ID and optional name (populated after verification)
 */
export type CourseEntry = { id: string; name: string | null }
/**
 * Directory layout for cloned repositories
 */
export type DirectoryLayout = "by-team" | "flat" | "by-task"
export type GenerateFilesParams = { base_url: string; access_token: string; course_id: string; lms_type: string; yaml_file: string; output_folder: string; csv_file: string; xlsx_file: string; member_option: string; include_group: boolean; include_member: boolean; include_initials: boolean; full_groups: boolean; csv: boolean; xlsx: boolean; yaml: boolean }
export type GetGroupCategoriesParams = { base_url: string; access_token: string; course_id: string; lms_type: string }
export type GetGroupsParams = { base_url: string; access_token: string; course_id: string; lms_type: string; group_category_id: string | null }
/**
 * GitHub-specific configuration (no base_url - always github.com)
 */
export type GitHubConfig = { access_token: string; user: string; student_repos_org: string; template_org: string }
/**
 * GitLab-specific configuration (requires base_url)
 */
export type GitLabConfig = { access_token: string; base_url: string; user: string; student_repos_group: string; template_group: string }
/**
 * Git server types for repository management
 */
export type GitServerType = "GitHub" | "GitLab" | "Gitea"
/**
 * Git server settings (shared across apps)
 */
export type GitSettings = { gitea: GiteaConfig; github: GitHubConfig; gitlab: GitLabConfig; type: GitServerType }
/**
 * Gitea-specific configuration (requires base_url)
 */
export type GiteaConfig = { access_token: string; base_url: string; user: string; student_repos_group: string; template_group: string }
/**
 * Group for frontend binding
 */
export type Group = { id: string; name: string; group_category_id: string | null; members_count: number | null }
/**
 * Group category (group set) for frontend binding
 */
export type GroupCategory = { id: string; name: string; role: string | null; self_signup: string | null; course_id: string | null; group_limit: number | null }
/**
 * Combined GUI settings (sent to frontend)
 * This combines app settings with the active profile's settings
 */
export type GuiSettings = 
/**
 * App-level settings (from app.json)
 */
({ active_tab: ActiveTab; 
/**
 * IDs of collapsed sections (e.g., ["lms-config", "options"])
 */
collapsed_sections?: string[]; logging: LogSettings; sidebar_open: boolean; theme: Theme; window_height: number; window_width: number }) & 
/**
 * Profile settings (from active profile)
 */
({ git: GitSettings; lms: LmsSettings; repo: RepoSettings })
/**
 * LMS app settings (Tab 1)
 */
export type LmsSettings = { canvas: CanvasConfig; moodle: MoodleConfig; type: string; csv_file: string; full_groups: boolean; include_group: boolean; include_initials: boolean; include_member: boolean; member_option: MemberOption; output_csv: boolean; output_folder: string; output_xlsx: boolean; output_yaml: boolean; xlsx_file: string; yaml_file: string }
/**
 * LMS URL preset options
 */
export type LmsUrlOption = "TUE" | "CUSTOM"
/**
 * Logging settings (stored in AppSettings)
 */
export type LogSettings = { debug: boolean; error: boolean; info: boolean; warning: boolean }
/**
 * Member option for YAML generation
 */
export type MemberOption = "(email, gitid)" | "email" | "git_id"
/**
 * Moodle-specific LMS configuration
 */
export type MoodleConfig = { access_token: string; base_url: string; courses: CourseEntry[] }
/**
 * Profile settings (nested structure for per-profile data)
 */
export type ProfileSettings = { git: GitSettings; lms: LmsSettings; repo: RepoSettings }
/**
 * Repo app settings (Tab 2)
 */
export type RepoSettings = { assignments: string; directory_layout: DirectoryLayout; target_folder: string; yaml_file: string }
/**
 * Result of loading settings, including any warnings about corrected issues
 */
export type SettingsLoadResult = { 
/**
 * The loaded settings (with defaults applied for invalid/missing values)
 */
settings: GuiSettings; 
/**
 * Warnings about issues found in the settings file
 * (unknown fields removed, invalid values replaced with defaults)
 */
warnings: string[] }
export type SetupParams = { config: ConfigParams; yaml_file: string; assignments: string }
/**
 * UI theme
 */
export type Theme = "light" | "dark" | "system"
export type VerifyCourseParams = { base_url: string; access_token: string; course_id: string; lms_type: string }
export type VerifyCourseResult = { course_id: string; course_name: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

// @ts-expect-error Generated but unused when no events defined
function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}