// DO NOT EDIT - Generated by scripts/gen-from-schema.ts
// Source: apps/repo-manage/schemas/commands/manifest.json
// To modify commands, edit the manifest and run `pnpm gen:bindings`

import type {
  BackendAPI,
  CloseRequestedHandler,
  OpenDialogOptions,
  ProgressCallback,
  SaveDialogOptions,
  WindowTheme,
} from "@repo-edu/backend-interface"
import type {
  AppError,
  AppSettings,
  AssignmentId,
  CloneConfig,
  CommandResult,
  CourseInfo,
  CourseVerifyResult,
  CreateConfig,
  DeleteConfig,
  GenerateFilesParams,
  GetGroupCategoriesParams,
  GitConnection,
  GitIdentityMode,
  GitVerifyResult,
  GroupCategory,
  GroupSelectionMode,
  GroupSelectionPreview,
  GroupSetImportPreview,
  GroupSetImportResult,
  GroupSetSyncResult,
  ImportGitUsernamesResult,
  ImportRosterResult,
  ImportStudentsResult,
  LmsConnection,
  LmsContextKey,
  LmsGroup,
  LmsGroupSet,
  LmsOperationContext,
  LmsType,
  LmsVerifyResult,
  OperationResult,
  PatternFilterResult,
  ProfileSettings,
  RepoOperationContext,
  RepoPreflightResult,
  Result,
  Roster,
  SettingsLoadResult,
  SystemGroupSetEnsureResult,
  UsernameVerificationScope,
  ValidationResult,
  VerifyCourseParams,
  VerifyCourseResult,
  VerifyGitUsernamesResult,
} from "@repo-edu/backend-interface/types"
import {
  Channel as TAURI_CHANNEL,
  invoke as TAURI_INVOKE,
} from "@tauri-apps/api/core"
import { listen as TAURI_LISTEN } from "@tauri-apps/api/event"
import { getCurrentWindow } from "@tauri-apps/api/window"
import {
  open as TAURI_OPEN,
  save as TAURI_SAVE,
} from "@tauri-apps/plugin-dialog"

function toAppError(e: unknown): AppError {
  if (typeof e === "object" && e !== null && "message" in e)
    return e as AppError
  return { message: String(e) }
}

export class TauriBackend implements BackendAPI {
  /**
   * Get token generation instructions for an LMS type
   */
  async getTokenInstructions(
    lmsType: string,
  ): Promise<Result<string, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_token_instructions", { lmsType }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Open the LMS token generation page in the browser
   */
  async openTokenUrl(
    baseUrl: string,
    lmsType: string,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("open_token_url", { baseUrl, lmsType }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Verify LMS course credentials and fetch course information
   */
  async verifyLmsCourse(
    params: VerifyCourseParams,
  ): Promise<Result<VerifyCourseResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("verify_lms_course", { params }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Generate student files from an LMS course
   */
  async generateLmsFiles(
    params: GenerateFilesParams,
    progress: ProgressCallback<string>,
  ): Promise<Result<CommandResult, AppError>> {
    const progressChannel = new TAURI_CHANNEL<string>()
    progressChannel.onmessage = progress
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("generate_lms_files", {
          params,
          progress: progressChannel,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Get group categories (group sets) for a course
   */
  async getGroupCategories(
    params: GetGroupCategoriesParams,
  ): Promise<Result<GroupCategory[], AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_group_categories", { params }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Verify LMS connection using app-level LMS connection
   */
  async verifyLmsConnection(
    context: LmsOperationContext,
  ): Promise<Result<LmsVerifyResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("verify_lms_connection", { context }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Verify draft LMS connection (before saving)
   */
  async verifyLmsConnectionDraft(
    context: LmsOperationContext,
  ): Promise<Result<LmsVerifyResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("verify_lms_connection_draft", { context }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Fetch courses from LMS (for profile creation)
   */
  async fetchLmsCourses(): Promise<Result<CourseInfo[], AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("fetch_lms_courses") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Fetch courses using draft connection (inline setup)
   */
  async fetchLmsCoursesDraft(
    connection: LmsConnection,
  ): Promise<Result<CourseInfo[], AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("fetch_lms_courses_draft", { connection }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Import students from LMS, merge into roster
   */
  async importStudentsFromLms(
    context: LmsOperationContext,
    roster: Roster | null,
  ): Promise<Result<ImportStudentsResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("import_students_from_lms", {
          context,
          roster,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Import students from CSV/Excel file
   */
  async importStudentsFromFile(
    profile: string,
    roster: Roster | null,
    filePath: string,
  ): Promise<Result<ImportStudentsResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("import_students_from_file", {
          profile,
          roster,
          filePath,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Fetch group-set names/ids only (fast)
   */
  async fetchLmsGroupSetList(
    context: LmsOperationContext,
  ): Promise<Result<LmsGroupSet[], AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("fetch_lms_group_set_list", { context }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Fetch groups for a specific group-set
   */
  async fetchLmsGroupsForSet(
    context: LmsOperationContext,
    groupSetId: string,
  ): Promise<Result<LmsGroup[], AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("fetch_lms_groups_for_set", {
          context,
          groupSetId,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Sync LMS group set: fetch from LMS, update groups in place
   */
  async syncGroupSet(
    context: LmsOperationContext,
    roster: Roster,
    groupSetId: string,
    progress: ProgressCallback<string>,
  ): Promise<Result<GroupSetSyncResult, AppError>> {
    const progressChannel = new TAURI_CHANNEL<string>()
    progressChannel.onmessage = progress
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("sync_group_set", {
          context,
          roster,
          groupSetId,
          progress: progressChannel,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Import full roster from LMS (students + staff), merge into existing roster
   */
  async importRosterFromLms(
    context: LmsOperationContext,
    roster: Roster | null,
    progress: ProgressCallback<string>,
  ): Promise<Result<ImportRosterResult, AppError>> {
    const progressChannel = new TAURI_CHANNEL<string>()
    progressChannel.onmessage = progress
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("import_roster_from_lms", {
          context,
          roster,
          progress: progressChannel,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Create/repair system group sets and normalize group memberships (idempotent)
   */
  async ensureSystemGroupSets(
    roster: Roster,
  ): Promise<Result<SystemGroupSetEnsureResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("ensure_system_group_sets", { roster }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Normalize a group name using backend slug rules
   */
  async normalizeGroupName(name: string): Promise<Result<string, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("normalize_group_name", { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Validate glob and resolve group IDs for assignment preview
   */
  async previewGroupSelection(
    roster: Roster,
    groupSetId: string,
    groupSelection: GroupSelectionMode,
  ): Promise<Result<GroupSelectionPreview, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("preview_group_selection", {
          roster,
          groupSetId,
          groupSelection,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Validate glob and return matched value indexes for UI filtering
   */
  async filterByPattern(
    pattern: string,
    values: string[],
  ): Promise<Result<PatternFilterResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("filter_by_pattern", { pattern, values }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Parse CSV for import preview (no persistence)
   */
  async previewImportGroupSet(
    roster: Roster,
    filePath: string,
  ): Promise<Result<GroupSetImportPreview, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("preview_import_group_set", {
          roster,
          filePath,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Parse CSV and create new group set
   */
  async importGroupSet(
    roster: Roster,
    filePath: string,
  ): Promise<Result<GroupSetImportResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("import_group_set", { roster, filePath }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Re-parse CSV for reimport preview (no persistence)
   */
  async previewReimportGroupSet(
    roster: Roster,
    groupSetId: string,
    filePath: string,
  ): Promise<Result<GroupSetImportPreview, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("preview_reimport_group_set", {
          roster,
          groupSetId,
          filePath,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Re-parse CSV and update existing group set
   */
  async reimportGroupSet(
    roster: Roster,
    groupSetId: string,
    filePath: string,
  ): Promise<Result<GroupSetImportResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("reimport_group_set", {
          roster,
          groupSetId,
          filePath,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Export group set to CSV file
   */
  async exportGroupSet(
    roster: Roster,
    groupSetId: string,
    filePath: string,
  ): Promise<Result<string, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("export_group_set", {
          roster,
          groupSetId,
          filePath,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Normalize LMS context fields (type, base URL, course)
   */
  async normalizeContext(
    lmsType: LmsType,
    baseUrl: string,
    courseId: string,
  ): Promise<Result<LmsContextKey, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("normalize_context", {
          lmsType,
          baseUrl,
          courseId,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Verify profile course exists in LMS and return updated name if changed
   */
  async verifyProfileCourse(
    profile: string,
  ): Promise<Result<CourseVerifyResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("verify_profile_course", { profile }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Verify named git connection
   */
  async verifyGitConnection(
    name: string,
  ): Promise<Result<GitVerifyResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("verify_git_connection", { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Verify draft git connection (before saving)
   */
  async verifyGitConnectionDraft(
    connection: GitConnection,
  ): Promise<Result<GitVerifyResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("verify_git_connection_draft", { connection }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * List all available profiles
   */
  async listProfiles(): Promise<Result<string[], AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("list_profiles") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Get the currently active profile
   */
  async getActiveProfile(): Promise<Result<string | null, AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_active_profile") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Set the active profile
   */
  async setActiveProfile(name: string): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("set_active_profile", { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Load a profile by name, returning any migration warnings
   */
  async loadProfile(
    name: string,
  ): Promise<Result<SettingsLoadResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("load_profile", { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Load a profile by name without changing the active profile
   */
  async loadProfileSettings(
    name: string,
  ): Promise<Result<SettingsLoadResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("load_profile_settings", { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Save profile settings as a named profile (app settings are not touched)
   */
  async saveProfile(
    name: string,
    profile: ProfileSettings,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("save_profile", { name, profile }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Save profile settings and roster together (atomic)
   */
  async saveProfileAndRoster(
    name: string,
    profile: ProfileSettings,
    roster: Roster | null,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("save_profile_and_roster", {
          name,
          profile,
          roster,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Delete a profile by name
   */
  async deleteProfile(name: string): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("delete_profile", { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Rename a profile
   */
  async renameProfile(
    oldName: string,
    newName: string,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("rename_profile", { oldName, newName }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Create a new profile with required course binding
   */
  async createProfile(
    name: string,
    course: CourseInfo,
  ): Promise<Result<ProfileSettings, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("create_profile", { name, course }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Load settings from disk with warnings for any corrected issues
   */
  async loadSettings(): Promise<Result<SettingsLoadResult, AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("load_settings") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Load app-level settings (theme, window position, etc.)
   */
  async loadAppSettings(): Promise<Result<AppSettings, AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("load_app_settings") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Save only app-level settings (theme, window position, etc.)
   */
  async saveAppSettings(
    settings: AppSettings,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("save_app_settings", { settings }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * List saved git connection names
   */
  async listGitConnections(): Promise<Result<string[], AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("list_git_connections") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Get a named git connection
   */
  async getGitConnection(
    name: string,
  ): Promise<Result<GitConnection, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_git_connection", { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Save a named git connection
   */
  async saveGitConnection(
    name: string,
    connection: GitConnection,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("save_git_connection", { name, connection }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Delete a named git connection
   */
  async deleteGitConnection(name: string): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("delete_git_connection", { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Get identity mode for a connection name
   */
  async getIdentityMode(
    connectionName: string,
  ): Promise<Result<GitIdentityMode, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_identity_mode", { connectionName }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Reset settings to defaults
   */
  async resetSettings(): Promise<Result<ProfileSettings, AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("reset_settings") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Get default settings (single source of truth from Rust)
   */
  async getDefaultSettings(): Promise<ProfileSettings> {
    return await TAURI_INVOKE("get_default_settings")
  }

  /**
   * Get settings file path
   */
  async getSettingsPath(): Promise<Result<string, AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_settings_path") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Check if settings file exists
   */
  async settingsExist(): Promise<Result<boolean, AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("settings_exist") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Import settings from a specific file
   */
  async importSettings(
    path: string,
  ): Promise<Result<ProfileSettings, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("import_settings", { path }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Export settings to a specific file
   */
  async exportSettings(
    settings: ProfileSettings,
    path: string,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("export_settings", { settings, path }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Get the JSON schema for ProfileSettings
   */
  async getSettingsSchema(): Promise<Result<string, AppError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_settings_schema") }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Load settings or return defaults (never fails)
   */
  async loadSettingsOrDefault(): Promise<Result<ProfileSettings, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("load_settings_or_default"),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Load roster by profile name
   */
  async getRoster(profile: string): Promise<Result<Roster | null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_roster", { profile }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Clear roster data for a profile
   */
  async clearRoster(profile: string): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("clear_roster", { profile }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Import git usernames from CSV
   */
  async importGitUsernames(
    profile: string,
    roster: Roster,
    csvPath: string,
  ): Promise<Result<ImportGitUsernamesResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("import_git_usernames", {
          profile,
          roster,
          csvPath,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Verify git usernames exist on platform
   */
  async verifyGitUsernames(
    profile: string,
    roster: Roster,
    scope: UsernameVerificationScope,
  ): Promise<Result<VerifyGitUsernamesResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("verify_git_usernames", {
          profile,
          roster,
          scope,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Export teams to YAML for git operations
   */
  async exportTeams(
    profile: string,
    roster: Roster,
    assignmentId: AssignmentId,
    path: string,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("export_teams", {
          profile,
          roster,
          assignmentId,
          path,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Export assignment groups for external editing
   */
  async exportGroupsForEdit(
    roster: Roster,
    assignmentId: AssignmentId,
    path: string,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("export_groups_for_edit", {
          roster,
          assignmentId,
          path,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Export all students to CSV/XLSX
   */
  async exportStudents(
    roster: Roster,
    path: string,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("export_students", { roster, path }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Export assignment students with group info
   */
  async exportAssignmentStudents(
    roster: Roster,
    assignmentId: AssignmentId,
    path: string,
  ): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("export_assignment_students", {
          roster,
          assignmentId,
          path,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Validate roster (students)
   */
  async validateRoster(
    roster: Roster,
  ): Promise<Result<ValidationResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("validate_roster", { roster }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Validate assignment groups within a roster
   */
  async validateAssignment(
    identityMode: GitIdentityMode,
    roster: Roster,
    assignmentId: AssignmentId,
  ): Promise<Result<ValidationResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("validate_assignment", {
          identityMode,
          roster,
          assignmentId,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Preflight check for create: identifies repos that already exist
   */
  async preflightCreateRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: CreateConfig,
  ): Promise<Result<RepoPreflightResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("preflight_create_repos", {
          context,
          roster,
          assignmentId,
          config,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Preflight check for clone: identifies repos that don't exist
   */
  async preflightCloneRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: CloneConfig,
  ): Promise<Result<RepoPreflightResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("preflight_clone_repos", {
          context,
          roster,
          assignmentId,
          config,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Preflight check for delete: identifies repos that don't exist
   */
  async preflightDeleteRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: DeleteConfig,
  ): Promise<Result<RepoPreflightResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("preflight_delete_repos", {
          context,
          roster,
          assignmentId,
          config,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Create repos for assignment groups
   */
  async createRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: CreateConfig,
  ): Promise<Result<OperationResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("create_repos", {
          context,
          roster,
          assignmentId,
          config,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Clone repos for assignment groups
   */
  async cloneReposFromRoster(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: CloneConfig,
  ): Promise<Result<OperationResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("clone_repos_from_roster", {
          context,
          roster,
          assignmentId,
          config,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Delete repos for assignment groups
   */
  async deleteRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: DeleteConfig,
  ): Promise<Result<OperationResult, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("delete_repos", {
          context,
          roster,
          assignmentId,
          config,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Open the profiles directory in the system file manager
   */
  async revealProfilesDirectory(): Promise<Result<null, AppError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("reveal_profiles_directory"),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      return { status: "error", error: toAppError(e) }
    }
  }

  /**
   * Open a file or folder selection dialog.
   */
  async openDialog(options: OpenDialogOptions): Promise<string | null> {
    const result = await TAURI_OPEN(options)
    if (Array.isArray(result)) {
      return result[0] ?? null
    }
    return result ?? null
  }

  /**
   * Open a file save dialog.
   */
  async saveDialog(options: SaveDialogOptions): Promise<string | null> {
    return TAURI_SAVE(options)
  }

  /**
   * Listen for platform events such as menu actions.
   */
  async listenEvent<T = unknown>(
    event: string,
    handler: (payload: T) => void,
  ): Promise<() => void> {
    const unlisten = await TAURI_LISTEN(event, (event) => {
      handler(event.payload as T)
    })
    return unlisten
  }

  /**
   * Register a handler for window close requests.
   */
  async onCloseRequested(handler: CloseRequestedHandler): Promise<() => void> {
    const currentWindow = getCurrentWindow()
    const unlisten = await currentWindow.onCloseRequested((event) => {
      handler({
        preventDefault: () => event.preventDefault(),
      })
    })
    return unlisten
  }

  /**
   * Programmatically close the current window.
   */
  async closeWindow(): Promise<void> {
    const currentWindow = getCurrentWindow()
    await currentWindow.close()
  }

  /**
   * Set the window theme for platform chrome.
   */
  async setWindowTheme(theme: WindowTheme): Promise<void> {
    const resolvedTheme = theme === "system" ? null : theme
    const currentWindow = getCurrentWindow()
    await currentWindow.setTheme(resolvedTheme)
  }

  /**
   * Set the window background color.
   */
  async setWindowBackgroundColor(color: string): Promise<void> {
    const currentWindow = getCurrentWindow()
    await currentWindow.setBackgroundColor(color)
  }
}
