================================================================================
SETTINGS ARCHITECTURE ANALYSIS - gitinspectorgui-old
================================================================================

ANALYSIS COMPLETE - Three comprehensive documents created:

1. FULL TECHNICAL ANALYSIS (1080 lines)
   File: /tmp/settings_architecture_analysis.md
   
   Contents:
   - Executive Summary
   - Settings Storage (files, location, format)
   - Settings Structure (class hierarchy, JSON schema)
   - Settings Management (load, save, advanced operations)
   - UI Integration (GUI binding, conversions)
   - Default Values (hierarchy and fallbacks)
   - Persistence Model (when/how settings are saved)
   - Configuration File Format (JSON, POSIX paths)
   - Settings Modules Organization (file structure, responsibilities)
   - State Management (data flow, conversions)
   - Multi-Configuration Support (profiles via location pointer)
   - Architecture Patterns & Best Practices (8 key patterns)
   - Comparison with Tauri patterns
   - Lessons for repobee-tauri
   - Recommended Rust implementation strategy
   - File references with line numbers

2. QUICK REFERENCE GUIDE (400+ lines)
   File: /tmp/settings_quick_reference.md
   
   Contents:
   - Architecture overview diagram
   - Data flow diagrams (load/save)
   - File storage details with JSON examples
   - Core class hierarchy (Args, Settings, CLIArgs)
   - Key classes & methods reference
   - GUI integration points
   - GUI event handlers
   - Validation strategy
   - Best practices table
   - When settings are persisted table
   - Critical code locations
   - 10 key lessons for Tauri implementation

3. DETAILED CODE FLOW (400+ lines)
   File: /tmp/settings_code_flow.md
   
   Contents:
   - Complete application flow with line numbers
   - GUI initialization sequence
   - Main event loop - all settings operations
   - normalize() method deep dive
   - from_values_dict() deep dive
   - window_state_from_settings() deep dive
   - Data structures in memory
   - GUI window structure (values dict)
   - Error handling flow
   - Key conversions & transformations

================================================================================
KEY FINDINGS - GITINSPECTORGUI-OLD ARCHITECTURE
================================================================================

STORAGE:
  Location: ~/.config/gitinspectorgui/ (platform-aware via platformdirs)
  Files: gitinspectorgui.json + gitinspectorgui-location.json
  Format: JSON with JSON Schema validation

STRUCTURE:
  3-tier class hierarchy: Args → Settings, Args → CLIArgs
  33+ persistent settings fields
  Parallel Keys classes for type-safe GUI access
  Methods: load, save, save_as, reset, normalize, from_values_dict, as_system

PERSISTENCE:
  Model: EXPLICIT SAVE (not auto-save)
  When: User clicks Save/Save As button, or CLI --save flag
  Where: Active location tracked by gitinspectorgui-location.json
  Fallback: Missing file → defaults + warning

VALIDATION:
  Tool: jsonschema library
  Schema: Strict validation before/after persistence
  Enums: fix, view, file_formats, blame_exclusions
  Constraints: additionalProperties=False, minProperties=33

GUI BINDING:
  Load: window_state_from_settings() - settings → GUI elements
  Save: from_values_dict() - GUI elements → settings
  Bridge: Dict transformation at UI boundary (CSV → lists, etc.)

NORMALIZATION:
  When: On load and save (boundary operations)
  What: Strip whitespace, split CSV, convert paths to POSIX
  Purpose: Handle user quirks, ensure portability

ERROR HANDLING:
  Strategy: Return (obj, error_str) tuples instead of exceptions
  Graceful: Missing file → defaults instead of crash
  User feedback: Warning message about saving settings

PATTERNS USED:
  1. Dataclass + JSON Schema combination
  2. Three-tier class hierarchy
  3. Parallel Keys mirror structure
  4. Normalize on load and save
  5. Explicit error handling in load
  6. Location pointer for flexibility
  7. Values dictionary bridge
  8. Post-initialization validation

================================================================================
CRITICAL FILES IN GITINSPECTORGUI-OLD
================================================================================

Path: /Users/dvbeek/1-repos/github-boost/gitinspectorgui-old/src/gigui/

args_settings.py (474 lines) - CORE
├── class Args (31 fields, base for CLI/GUI)
├── class Settings extends Args (adds gui_settings_full_path)
│   ├── save() - persist to JSON
│   ├── save_as(path) - save to custom location
│   ├── load_safe_from(file) - load with error recovery
│   ├── reset() - restore defaults
│   ├── normalize() - clean input
│   ├── from_values_dict(values) - GUI → Settings conversion
│   └── as_system() - POSIX → system paths
├── class CLIArgs extends Args (8 CLI-specific flags)
├── class SettingsFile (static methods for file operations)
│   ├── SETTINGS_SCHEMA - JSON schema definition
│   ├── load() - from active location
│   ├── load_from(file) - from specific file
│   ├── load_safe() - with fallback
│   ├── get_location_path() - read location pointer
│   ├── set_location(path) - update location pointer
│   └── reset() - reset to defaults

constants.py (95 lines)
├── DEFAULT_FILE_BASE = "gitinspect"
├── DEFAULT_EXTENSIONS = ["c", "cpp", "h", "java", "js", "py", ...]
├── FIX_TYPE = ["prefix", "postfix", "nofix"]
├── VIEW_OPTIONS = ["auto", "dynamic-blame-history", "none"]
├── FILE_FORMATS = ["html", "excel"]
├── BLAME_EXCLUSION_CHOICES = ["hide", "show", "remove"]

keys.py (101 lines)
├── class KeysArgs - mirrors Args fields
└── class Keys extends KeysArgs - adds GUI-specific keys

cli.py (198 lines)
├── main() - entry point
├── load_settings(save, save_as) - app initialization
└── Settings/CLIArgs/Args conversion logic

gui/psg_base.py (300+ lines)
├── window_state_from_settings() - Settings → GUI
├── from_values_dict() location and related methods
└── GUI element synchronization

gui/psg.py (300+ lines)
├── PSGUI class - main event loop
├── Event handlers for save, load, reset operations
└── Settings interaction during runtime

gui/psg_window.py (556 lines)
├── make_window() - create GUI
├── settings_frame() - settings control panel
├── Save, Load, Reset button layout

================================================================================
ARCHITECTURE DIAGRAM
================================================================================

Application Start
    │
    ├─ load_settings()
    │  ├─ SettingsFile.get_location_path()  [reads location pointer]
    │  ├─ SettingsFile.load_from(path)      [loads and validates JSON]
    │  └─ Returns Settings object with defaults fallback
    │
    ├─ Branch: --gui or --run
    │
    └─ PSGUI(settings)  [GUI mode]
       ├─ window_state_from_settings()       [Settings → GUI elements]
       ├─ Main event loop: event, values = window.read()
       │
       ├─ Event: keys.save
       │  ├─ from_values_dict(values)        [GUI → Settings]
       │  ├─ normalize()                     [Clean paths/whitespace]
       │  ├─ validate with SETTINGS_SCHEMA
       │  └─ create_settings_file()          [Persist JSON]
       │
       ├─ Event: keys.load
       │  ├─ load_safe_from(file)
       │  ├─ set_location(file)              [Update pointer]
       │  └─ window_state_from_settings()    [Reload GUI]
       │
       ├─ Event: keys.reset
       │  ├─ reset()                         [Restore defaults]
       │  └─ window.close() + recreate_window
       │
       └─ Event: keys.exit or WIN_CLOSED
          └─ close() and exit

================================================================================
BEST PRACTICES IDENTIFIED
================================================================================

Pattern 1: Dataclass + JSON Schema
  Benefits: Type-safe, validated, self-documenting, IDE support
  Implementation: @dataclass Args/Settings + jsonschema validation

Pattern 2: Three-Tier Class Hierarchy
  Benefits: Code reuse, separation of concerns, clear structure
  Structure: Args (common) → Settings (GUI) → CLIArgs (CLI)

Pattern 3: Parallel Keys Mirror Classes
  Benefits: Type-safe GUI element access, eliminates magic strings
  Example: KeysArgs mirrors Args fields, Keys adds GUI-specific keys

Pattern 4: Normalize on Load and Save
  Benefits: Handles user quirks, ensures portability (POSIX paths)
  When: At boundary between user input and persistence

Pattern 5: Explicit Error Handling
  Benefits: Graceful degradation, clear error info, app continues
  How: Return (obj, error_str) tuples instead of raising exceptions

Pattern 6: Location Pointer Pattern
  Benefits: Multiple profiles without complex merging, flexible paths
  Implementation: Separate file tracking "active" settings location

Pattern 7: Values Dictionary Bridge
  Benefits: Isolates GUI from settings format, complex conversion in one place
  Method: from_values_dict() handles all type/format conversions

Pattern 8: Post-Initialization Validation
  Benefits: Tied to data structure, automatic enforcement, IDE understanding
  How: Override __post_init__ in dataclass for custom validation

================================================================================
IMPLEMENTATION RECOMMENDATIONS FOR REPOBEE-TAURI
================================================================================

1. Use Rust structs with serde for serialization (standard in Rust)
2. Use jsonschema crate for validation (if strict validation needed)
3. Use dirs/directories crate for platform-specific config paths
4. Implement location pointer separately for multiple profiles
5. Use explicit save() method (not auto-save)
6. Return Result<T, E> types for error handling (Rust idiom)
7. Validate on load path before creating AppSettings
8. Normalize paths to POSIX format for portability
9. Implement three-tier architecture: CommonSettings → GuiSettings/CliArgs
10. Mirror the Keys pattern with Rust enums or string constants

Rust Example Structure:
  src-tauri/src/
  ├── settings.rs (AppSettings, GuiState, SettingsManager)
  ├── settings/location.rs (LocationPointer)
  └── settings/validation.rs (Validate schema)

Key Differences from Python:
  - serde instead of dataclass
  - Result<T, E> instead of (T, error_str)
  - Enums for Settings keys instead of parallel dataclasses
  - File operations with std::fs or tokio::fs

================================================================================
END OF ANALYSIS SUMMARY
================================================================================

All three documents are ready in /tmp/:
1. settings_architecture_analysis.md (full technical)
2. settings_quick_reference.md (quick reference)
3. settings_code_flow.md (detailed code flow)

Copy these files to repobee-tauri for implementation guidance.
