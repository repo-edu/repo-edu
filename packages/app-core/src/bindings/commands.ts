// DO NOT EDIT - Generated by scripts/gen-from-schema.ts
// Source: apps/repo-manage/schemas/commands/manifest.json
// To modify commands, edit the manifest and run `pnpm gen:bindings`

import type { ProgressCallback } from "@repo-edu/backend-interface"
import type {
  AppError,
  AppSettings,
  AssignmentId,
  CloneConfig,
  CommandResult,
  CourseInfo,
  CourseVerifyResult,
  CoverageExportFormat,
  CoverageReport,
  CreateConfig,
  DeleteConfig,
  GenerateFilesParams,
  GetGroupCategoriesParams,
  GitConnection,
  GitIdentityMode,
  GitVerifyResult,
  GroupCategory,
  GroupSelectionMode,
  GroupSelectionPreview,
  GroupSetImportPreview,
  GroupSetImportResult,
  GroupSetSyncResult,
  ImportGitUsernamesResult,
  ImportRosterResult,
  ImportStudentsResult,
  LmsConnection,
  LmsContextKey,
  LmsGroup,
  LmsGroupSet,
  LmsOperationContext,
  LmsType,
  LmsVerifyResult,
  OperationResult,
  PatternFilterResult,
  ProfileSettings,
  RepoOperationContext,
  RepoPreflightResult,
  Result,
  Roster,
  RosterMemberId,
  SettingsLoadResult,
  StudentRemovalCheck,
  SystemGroupSetEnsureResult,
  UsernameVerificationScope,
  ValidationResult,
  VerifyCourseParams,
  VerifyCourseResult,
  VerifyGitUsernamesResult,
} from "@repo-edu/backend-interface/types"
import { getBackend } from "../services/backend"

export const commands = {
  /**
   * Get token generation instructions for an LMS type
   */
  getTokenInstructions(lmsType: string): Promise<Result<string, AppError>> {
    return getBackend().getTokenInstructions(lmsType)
  },
  /**
   * Open the LMS token generation page in the browser
   */
  openTokenUrl(
    baseUrl: string,
    lmsType: string,
  ): Promise<Result<null, AppError>> {
    return getBackend().openTokenUrl(baseUrl, lmsType)
  },
  /**
   * Verify LMS course credentials and fetch course information
   */
  verifyLmsCourse(
    params: VerifyCourseParams,
  ): Promise<Result<VerifyCourseResult, AppError>> {
    return getBackend().verifyLmsCourse(params)
  },
  /**
   * Generate student files from an LMS course
   */
  generateLmsFiles(
    params: GenerateFilesParams,
    progress: ProgressCallback<string>,
  ): Promise<Result<CommandResult, AppError>> {
    return getBackend().generateLmsFiles(params, progress)
  },
  /**
   * Get group categories (group sets) for a course
   */
  getGroupCategories(
    params: GetGroupCategoriesParams,
  ): Promise<Result<GroupCategory[], AppError>> {
    return getBackend().getGroupCategories(params)
  },
  /**
   * Verify LMS connection using app-level LMS connection
   */
  verifyLmsConnection(
    context: LmsOperationContext,
  ): Promise<Result<LmsVerifyResult, AppError>> {
    return getBackend().verifyLmsConnection(context)
  },
  /**
   * Verify draft LMS connection (before saving)
   */
  verifyLmsConnectionDraft(
    context: LmsOperationContext,
  ): Promise<Result<LmsVerifyResult, AppError>> {
    return getBackend().verifyLmsConnectionDraft(context)
  },
  /**
   * Fetch courses from LMS (for profile creation)
   */
  fetchLmsCourses(): Promise<Result<CourseInfo[], AppError>> {
    return getBackend().fetchLmsCourses()
  },
  /**
   * Fetch courses using draft connection (inline setup)
   */
  fetchLmsCoursesDraft(
    connection: LmsConnection,
  ): Promise<Result<CourseInfo[], AppError>> {
    return getBackend().fetchLmsCoursesDraft(connection)
  },
  /**
   * Import students from LMS, merge into roster
   */
  importStudentsFromLms(
    context: LmsOperationContext,
    roster: Roster | null,
  ): Promise<Result<ImportStudentsResult, AppError>> {
    return getBackend().importStudentsFromLms(context, roster)
  },
  /**
   * Import students from CSV/Excel file
   */
  importStudentsFromFile(
    profile: string,
    roster: Roster | null,
    filePath: string,
  ): Promise<Result<ImportStudentsResult, AppError>> {
    return getBackend().importStudentsFromFile(profile, roster, filePath)
  },
  /**
   * Fetch group-set names/ids only (fast)
   */
  fetchLmsGroupSetList(
    context: LmsOperationContext,
  ): Promise<Result<LmsGroupSet[], AppError>> {
    return getBackend().fetchLmsGroupSetList(context)
  },
  /**
   * Fetch groups for a specific group-set
   */
  fetchLmsGroupsForSet(
    context: LmsOperationContext,
    groupSetId: string,
  ): Promise<Result<LmsGroup[], AppError>> {
    return getBackend().fetchLmsGroupsForSet(context, groupSetId)
  },
  /**
   * Sync LMS group set: fetch from LMS, update groups in place
   */
  syncGroupSet(
    context: LmsOperationContext,
    roster: Roster,
    groupSetId: string,
  ): Promise<Result<GroupSetSyncResult, AppError>> {
    return getBackend().syncGroupSet(context, roster, groupSetId)
  },
  /**
   * Import full roster from LMS (students + staff), merge into existing roster
   */
  importRosterFromLms(
    context: LmsOperationContext,
    roster: Roster | null,
  ): Promise<Result<ImportRosterResult, AppError>> {
    return getBackend().importRosterFromLms(context, roster)
  },
  /**
   * Create/repair system group sets and normalize group memberships (idempotent)
   */
  ensureSystemGroupSets(
    roster: Roster,
  ): Promise<Result<SystemGroupSetEnsureResult, AppError>> {
    return getBackend().ensureSystemGroupSets(roster)
  },
  /**
   * Normalize a group name using backend slug rules
   */
  normalizeGroupName(name: string): Promise<Result<string, AppError>> {
    return getBackend().normalizeGroupName(name)
  },
  /**
   * Validate glob and resolve group IDs for assignment preview
   */
  previewGroupSelection(
    roster: Roster,
    groupSetId: string,
    groupSelection: GroupSelectionMode,
  ): Promise<Result<GroupSelectionPreview, AppError>> {
    return getBackend().previewGroupSelection(
      roster,
      groupSetId,
      groupSelection,
    )
  },
  /**
   * Validate glob and return matched value indexes for UI filtering
   */
  filterByPattern(
    pattern: string,
    values: string[],
  ): Promise<Result<PatternFilterResult, AppError>> {
    return getBackend().filterByPattern(pattern, values)
  },
  /**
   * Parse CSV for import preview (no persistence)
   */
  previewImportGroupSet(
    roster: Roster,
    filePath: string,
  ): Promise<Result<GroupSetImportPreview, AppError>> {
    return getBackend().previewImportGroupSet(roster, filePath)
  },
  /**
   * Parse CSV and create new group set
   */
  importGroupSet(
    roster: Roster,
    filePath: string,
  ): Promise<Result<GroupSetImportResult, AppError>> {
    return getBackend().importGroupSet(roster, filePath)
  },
  /**
   * Re-parse CSV for reimport preview (no persistence)
   */
  previewReimportGroupSet(
    roster: Roster,
    groupSetId: string,
    filePath: string,
  ): Promise<Result<GroupSetImportPreview, AppError>> {
    return getBackend().previewReimportGroupSet(roster, groupSetId, filePath)
  },
  /**
   * Re-parse CSV and update existing group set
   */
  reimportGroupSet(
    roster: Roster,
    groupSetId: string,
    filePath: string,
  ): Promise<Result<GroupSetImportResult, AppError>> {
    return getBackend().reimportGroupSet(roster, groupSetId, filePath)
  },
  /**
   * Export group set to CSV file
   */
  exportGroupSet(
    roster: Roster,
    groupSetId: string,
    filePath: string,
  ): Promise<Result<null, AppError>> {
    return getBackend().exportGroupSet(roster, groupSetId, filePath)
  },
  /**
   * Normalize LMS context fields (type, base URL, course)
   */
  normalizeContext(
    lmsType: LmsType,
    baseUrl: string,
    courseId: string,
  ): Promise<Result<LmsContextKey, AppError>> {
    return getBackend().normalizeContext(lmsType, baseUrl, courseId)
  },
  /**
   * Verify profile course exists in LMS and return updated name if changed
   */
  verifyProfileCourse(
    profile: string,
  ): Promise<Result<CourseVerifyResult, AppError>> {
    return getBackend().verifyProfileCourse(profile)
  },
  /**
   * Verify named git connection
   */
  verifyGitConnection(
    name: string,
  ): Promise<Result<GitVerifyResult, AppError>> {
    return getBackend().verifyGitConnection(name)
  },
  /**
   * Verify draft git connection (before saving)
   */
  verifyGitConnectionDraft(
    connection: GitConnection,
  ): Promise<Result<GitVerifyResult, AppError>> {
    return getBackend().verifyGitConnectionDraft(connection)
  },
  /**
   * List all available profiles
   */
  listProfiles(): Promise<Result<string[], AppError>> {
    return getBackend().listProfiles()
  },
  /**
   * Get the currently active profile
   */
  getActiveProfile(): Promise<Result<string | null, AppError>> {
    return getBackend().getActiveProfile()
  },
  /**
   * Set the active profile
   */
  setActiveProfile(name: string): Promise<Result<null, AppError>> {
    return getBackend().setActiveProfile(name)
  },
  /**
   * Load a profile by name, returning any migration warnings
   */
  loadProfile(name: string): Promise<Result<SettingsLoadResult, AppError>> {
    return getBackend().loadProfile(name)
  },
  /**
   * Load a profile by name without changing the active profile
   */
  loadProfileSettings(
    name: string,
  ): Promise<Result<SettingsLoadResult, AppError>> {
    return getBackend().loadProfileSettings(name)
  },
  /**
   * Save profile settings as a named profile (app settings are not touched)
   */
  saveProfile(
    name: string,
    profile: ProfileSettings,
  ): Promise<Result<null, AppError>> {
    return getBackend().saveProfile(name, profile)
  },
  /**
   * Save profile settings and roster together (atomic)
   */
  saveProfileAndRoster(
    name: string,
    profile: ProfileSettings,
    roster: Roster | null,
  ): Promise<Result<null, AppError>> {
    return getBackend().saveProfileAndRoster(name, profile, roster)
  },
  /**
   * Delete a profile by name
   */
  deleteProfile(name: string): Promise<Result<null, AppError>> {
    return getBackend().deleteProfile(name)
  },
  /**
   * Rename a profile
   */
  renameProfile(
    oldName: string,
    newName: string,
  ): Promise<Result<null, AppError>> {
    return getBackend().renameProfile(oldName, newName)
  },
  /**
   * Create a new profile with required course binding
   */
  createProfile(
    name: string,
    course: CourseInfo,
  ): Promise<Result<ProfileSettings, AppError>> {
    return getBackend().createProfile(name, course)
  },
  /**
   * Load settings from disk with warnings for any corrected issues
   */
  loadSettings(): Promise<Result<SettingsLoadResult, AppError>> {
    return getBackend().loadSettings()
  },
  /**
   * Load app-level settings (theme, window position, etc.)
   */
  loadAppSettings(): Promise<Result<AppSettings, AppError>> {
    return getBackend().loadAppSettings()
  },
  /**
   * Save only app-level settings (theme, window position, etc.)
   */
  saveAppSettings(settings: AppSettings): Promise<Result<null, AppError>> {
    return getBackend().saveAppSettings(settings)
  },
  /**
   * List saved git connection names
   */
  listGitConnections(): Promise<Result<string[], AppError>> {
    return getBackend().listGitConnections()
  },
  /**
   * Get a named git connection
   */
  getGitConnection(name: string): Promise<Result<GitConnection, AppError>> {
    return getBackend().getGitConnection(name)
  },
  /**
   * Save a named git connection
   */
  saveGitConnection(
    name: string,
    connection: GitConnection,
  ): Promise<Result<null, AppError>> {
    return getBackend().saveGitConnection(name, connection)
  },
  /**
   * Delete a named git connection
   */
  deleteGitConnection(name: string): Promise<Result<null, AppError>> {
    return getBackend().deleteGitConnection(name)
  },
  /**
   * Get identity mode for a connection name
   */
  getIdentityMode(
    connectionName: string,
  ): Promise<Result<GitIdentityMode, AppError>> {
    return getBackend().getIdentityMode(connectionName)
  },
  /**
   * Reset settings to defaults
   */
  resetSettings(): Promise<Result<ProfileSettings, AppError>> {
    return getBackend().resetSettings()
  },
  /**
   * Get default settings (single source of truth from Rust)
   */
  getDefaultSettings(): Promise<ProfileSettings> {
    return getBackend().getDefaultSettings()
  },
  /**
   * Get settings file path
   */
  getSettingsPath(): Promise<Result<string, AppError>> {
    return getBackend().getSettingsPath()
  },
  /**
   * Check if settings file exists
   */
  settingsExist(): Promise<Result<boolean, AppError>> {
    return getBackend().settingsExist()
  },
  /**
   * Import settings from a specific file
   */
  importSettings(path: string): Promise<Result<ProfileSettings, AppError>> {
    return getBackend().importSettings(path)
  },
  /**
   * Export settings to a specific file
   */
  exportSettings(
    settings: ProfileSettings,
    path: string,
  ): Promise<Result<null, AppError>> {
    return getBackend().exportSettings(settings, path)
  },
  /**
   * Get the JSON schema for ProfileSettings
   */
  getSettingsSchema(): Promise<Result<string, AppError>> {
    return getBackend().getSettingsSchema()
  },
  /**
   * Load settings or return defaults (never fails)
   */
  loadSettingsOrDefault(): Promise<Result<ProfileSettings, AppError>> {
    return getBackend().loadSettingsOrDefault()
  },
  /**
   * Load roster by profile name
   */
  getRoster(profile: string): Promise<Result<Roster | null, AppError>> {
    return getBackend().getRoster(profile)
  },
  /**
   * Clear roster data for a profile
   */
  clearRoster(profile: string): Promise<Result<null, AppError>> {
    return getBackend().clearRoster(profile)
  },
  /**
   * Check whether a student removal impacts any groups
   */
  checkStudentRemoval(
    profile: string,
    roster: Roster,
    studentId: RosterMemberId,
  ): Promise<Result<StudentRemovalCheck, AppError>> {
    return getBackend().checkStudentRemoval(profile, roster, studentId)
  },
  /**
   * Import git usernames from CSV
   */
  importGitUsernames(
    profile: string,
    roster: Roster,
    csvPath: string,
  ): Promise<Result<ImportGitUsernamesResult, AppError>> {
    return getBackend().importGitUsernames(profile, roster, csvPath)
  },
  /**
   * Verify git usernames exist on platform
   */
  verifyGitUsernames(
    profile: string,
    roster: Roster,
    scope: UsernameVerificationScope,
  ): Promise<Result<VerifyGitUsernamesResult, AppError>> {
    return getBackend().verifyGitUsernames(profile, roster, scope)
  },
  /**
   * Export teams to YAML for git operations
   */
  exportTeams(
    profile: string,
    roster: Roster,
    assignmentId: AssignmentId,
    path: string,
  ): Promise<Result<null, AppError>> {
    return getBackend().exportTeams(profile, roster, assignmentId, path)
  },
  /**
   * Export assignment groups for external editing
   */
  exportGroupsForEdit(
    roster: Roster,
    assignmentId: AssignmentId,
    path: string,
  ): Promise<Result<null, AppError>> {
    return getBackend().exportGroupsForEdit(roster, assignmentId, path)
  },
  /**
   * Export all students to CSV/XLSX
   */
  exportStudents(
    roster: Roster,
    path: string,
  ): Promise<Result<null, AppError>> {
    return getBackend().exportStudents(roster, path)
  },
  /**
   * Export assignment students with group info
   */
  exportAssignmentStudents(
    roster: Roster,
    assignmentId: AssignmentId,
    path: string,
  ): Promise<Result<null, AppError>> {
    return getBackend().exportAssignmentStudents(roster, assignmentId, path)
  },
  /**
   * Get coverage report (student distribution)
   */
  getRosterCoverage(roster: Roster): Promise<Result<CoverageReport, AppError>> {
    return getBackend().getRosterCoverage(roster)
  },
  /**
   * Export coverage report
   */
  exportRosterCoverage(
    roster: Roster,
    path: string,
    format: CoverageExportFormat,
  ): Promise<Result<null, AppError>> {
    return getBackend().exportRosterCoverage(roster, path, format)
  },
  /**
   * Validate roster (students)
   */
  validateRoster(roster: Roster): Promise<Result<ValidationResult, AppError>> {
    return getBackend().validateRoster(roster)
  },
  /**
   * Validate assignment groups within a roster
   */
  validateAssignment(
    identityMode: GitIdentityMode,
    roster: Roster,
    assignmentId: AssignmentId,
  ): Promise<Result<ValidationResult, AppError>> {
    return getBackend().validateAssignment(identityMode, roster, assignmentId)
  },
  /**
   * Preflight check for create: identifies repos that already exist
   */
  preflightCreateRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: CreateConfig,
  ): Promise<Result<RepoPreflightResult, AppError>> {
    return getBackend().preflightCreateRepos(
      context,
      roster,
      assignmentId,
      config,
    )
  },
  /**
   * Preflight check for clone: identifies repos that don't exist
   */
  preflightCloneRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: CloneConfig,
  ): Promise<Result<RepoPreflightResult, AppError>> {
    return getBackend().preflightCloneRepos(
      context,
      roster,
      assignmentId,
      config,
    )
  },
  /**
   * Preflight check for delete: identifies repos that don't exist
   */
  preflightDeleteRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: DeleteConfig,
  ): Promise<Result<RepoPreflightResult, AppError>> {
    return getBackend().preflightDeleteRepos(
      context,
      roster,
      assignmentId,
      config,
    )
  },
  /**
   * Create repos for assignment groups
   */
  createRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: CreateConfig,
  ): Promise<Result<OperationResult, AppError>> {
    return getBackend().createRepos(context, roster, assignmentId, config)
  },
  /**
   * Clone repos for assignment groups
   */
  cloneReposFromRoster(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: CloneConfig,
  ): Promise<Result<OperationResult, AppError>> {
    return getBackend().cloneReposFromRoster(
      context,
      roster,
      assignmentId,
      config,
    )
  },
  /**
   * Delete repos for assignment groups
   */
  deleteRepos(
    context: RepoOperationContext,
    roster: Roster,
    assignmentId: AssignmentId,
    config: DeleteConfig,
  ): Promise<Result<OperationResult, AppError>> {
    return getBackend().deleteRepos(context, roster, assignmentId, config)
  },
  /**
   * Open the profiles directory in the system file manager
   */
  revealProfilesDirectory(): Promise<Result<null, AppError>> {
    return getBackend().revealProfilesDirectory()
  },
}
